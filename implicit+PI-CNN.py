# -*- coding: utf-8 -*-
"""implicit_method.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JDJIDdqIjzeJZukdc-us4fmmAkv9r-ef

CNT Clumps
"""

from google.colab import drive
drive.mount('/content/drive')

import random
import math
import numpy as np
from matplotlib import pyplot as plt
from numba import jit

steps = 1
rows,cols = 512,512
number_of_particles = random.randint(20,30)         # was (15,20)
dt = 0.33
min_r,max_r = 22,27

jit(nopython=True)
def collide(p1,p2):
    x = p1.x - p2.x
    y = p1.y - p2.y
    slength = x*x+y*y
    length = math.sqrt(slength)
    target = p1.radius + p2.radius
    if length < target and length!=0:
        factor = (length-target)/length
        p1.x -= x*factor*0.5
        p1.y -= y*factor*0.5
        p2.x += x*factor*0.5
        p2.y += y*factor*0.5

jit(nopython=True)
def attract(p1,p2):
    x = p1.x - p2.x
    y = p1.y - p2.y
    slength = x*x+y*y
    force =5000000*p1.mass*p2.mass/(slength+80)
    if slength > (p1.radius + p2.radius)*(p1.radius + p2.radius):
      p1.x += (p1.x-p1.px)+0.5*(force/p1.mass)*dt*dt
      p1.y += (p1.y-p1.py)+0.5*(force/p1.mass)*dt*dt
      p2.x -= (p2.x-p2.px)+0.5*(force/p2.mass)*dt*dt
      p2.y -= (p2.y-p2.py)+0.5*(force/p2.mass)*dt*dt

class Particle():
  def __init__(self, x, y, radius, mass):
    self.x = x
    self.y = y
    self.px = x
    self.py = y
    self.radius = radius
    self.mass = mass
  def border_collide(self):
    if self.x > cols - self.radius:
        self.x = 2 * (cols - self.radius) - self.x
    elif self.x < self.radius:
        self.x = 2 * self.radius - self.x
    if self.y > rows - self.radius:
        self.y = 2 * (rows - self.radius) - self.y
    elif self.y < self.radius:
        self.y = 2 * self.radius - self.y

import math
import numpy as np
from matplotlib import pyplot as plt
import time
import scipy

def run_code(freq_in_THz,rows,cols,grid,variable_number):
  omega =2*math.pi*freq_in_THz*10**12
  h = 0.000000001
  mu = 4*math.pi*10**-7
  sigma = 59*10**6
  new_active = [[5,5]]
  new_active.remove([5,5])
  my_list = []
  starting_point = []
  starting_point.append([0, 0])
  outer_space = 50
  for pts in range(0,len(starting_point)):
      current_starting_point = starting_point[pts]
      start_row = current_starting_point[0]
      start_col = current_starting_point[1]
      my_list.append([start_row,start_col])
      old_active = []
      old_active.append([start_row, start_col])
      points_added = 99
      while points_added > 0:
        points_added = 0
        for doofy in range(0,len(old_active)):
          current_pt = old_active[doofy]
          row = current_pt[0]
          col = current_pt[1]
          if row-1 >= 0:
            if grid[row - 1][col] != outer_space and grid[row - 1][col] != 0:
              my_list.append([row - 1, col])
              points_added = points_added + 1
              grid[row - 1][col] = outer_space
              new_active.append([row-1,col])
          if row+1 <= N-1:
            if grid[row + 1][col] != outer_space and grid[row + 1][col] != 0:
              my_list.append([row + 1, col])
              points_added = points_added + 1
              grid[row + 1][col] = outer_space
              new_active.append([row+1,col])
          if col-1 >= 0:
            if grid[row][col - 1] != outer_space and grid[row][col - 1] != 0:
              my_list.append([row, col - 1])
              points_added = points_added + 1
              grid[row][col - 1] = outer_space
              new_active.append([row,col-1])
          if col+1 <= N-1:
            if grid[row][col + 1] != outer_space and grid[row][col + 1] != 0:
              my_list.append([row, col + 1])
              points_added = points_added + 1
              grid[row][col + 1] = outer_space
              new_active.append([row,col+1])
        old_active = new_active.copy()
        new_active = [[5, 5]]
        new_active.remove([5, 5])
  total_variables = np.count_nonzero(grid == 0)
  variable = 0
  for row in range(0,rows):
      for col in range(0,cols):
          if grid[row][col] == 0:
              variable_number[row][col] = variable
              variable=variable+1
  A = np.zeros((total_variables,total_variables),dtype=np.complex64)
  b = np.zeros((total_variables,1),dtype=np.complex64)
  for row in range(0,rows):
      for col in range(0,cols):
          if variable_number[row][col] != -1 and \
          variable_number[row][col-1] != -1 and \
          variable_number[row][col+1] != -1 and \
          variable_number[row-1][col] != -1 and \
          variable_number[row+1][col] != -1:
              which_variable = variable_number[row][col]
              A[which_variable][which_variable] = 4.+1j*omega*mu*sigma*h**2
              left_variable = variable_number[row][col-1]
              A[which_variable][left_variable] = -1
              right_variable = variable_number[row][col+1]
              A[which_variable][right_variable] = -1
              above_variable = variable_number[row-1][col]
              A[which_variable][above_variable] = -1
              below_variable = variable_number[row+1][col]
              A[which_variable][below_variable] = -1
          elif variable_number[row][col] != -1 and \
          variable_number[row][col-1] == -1:
              if grid[row][col-1] == outer_space:
                  which_variable = variable_number[row][col]
                  A[which_variable][which_variable] = 1.
                  b[which_variable][0] = 1j
              else:
                  which_variable = variable_number[row][col]
                  A[which_variable][which_variable] = 1.
                  right_variable = variable_number[row][col+1]
                  A[which_variable][right_variable] = -1
          elif variable_number[row][col] != -1 and \
                variable_number[row][col+1] == -1:
                if grid[row][col+1] == outer_space:
                    which_variable = variable_number[row][col]
                    A[which_variable][which_variable] = 1.
                    b[which_variable][0] = 1j
                else:
                    which_variable = variable_number[row][col]
                    A[which_variable][which_variable] = 1.
                    left_variable = variable_number[row][col-1]
                    A[which_variable][left_variable] = -1
          elif variable_number[row][col] != -1 and \
                variable_number[row-1][col] == -1:
                if grid[row-1][col] == outer_space:
                    which_variable = variable_number[row][col]
                    A[which_variable][which_variable] = 1.
                    b[which_variable][0] = 1j
                else:
                    which_variable = variable_number[row][col]
                    A[which_variable][which_variable] = 1.
                    down_variable = variable_number[row+1][col]
                    A[which_variable][down_variable] = -1
          elif variable_number[row][col] != -1 and \
                variable_number[row+1][col] == -1:
                if grid[row+1][col] == outer_space:
                    which_variable = variable_number[row][col]
                    A[which_variable][which_variable] = 1.
                    b[which_variable][0] = 1j
                else:
                    which_variable = variable_number[row][col]
                    A[which_variable][which_variable] = 1.
                    up_variable = variable_number[row-1][col]
                    A[which_variable][up_variable] = -1
          else:
              pass

  x = np.linalg.solve(A,b)
  J = np.zeros((rows,cols),dtype=np.complex64)
  current_variable = 0
  for row in range(0, rows):
      for col in range(0, cols):
          if variable_number[row][col] != -1:
              J[row][col] = x[current_variable][0]
              current_variable = current_variable + 1
  return J, variable_number

freq_list = []
for loop in range(0,100):
  try:
    ##################################### DRAW THE CNT #####################################
    my_particles = []
    for n in range(number_of_particles):
      if n == 0:
        x = 256
        y = 256
        radius = random.randint(min_r,max_r)
        mass = 500
        particle = Particle(x, y, radius, mass)
        my_particles.append(particle)
      else:
        x = random.randint(256-50,256+50)
        y = random.randint(256-50,256+50)
        radius = random.randint(min_r,max_r)
        d_from_center = ((x-256)*(x-256)+(y-256)*(y-256))**0.5
        mass = 30*math.exp(-0.025*d_from_center)
        particle = Particle(x, y, radius, mass)
        my_particles.append(particle)
    for _ in range(100):
      for i in my_particles:
        for j in my_particles:
          if i != j:
            collide(i,j)
    grid = 99*np.ones((rows,cols),dtype=int)
    for i in my_particles:
      cx = i.x
      cy = i.y
      radius = i.radius+2 # add 2 or 3 to promote overlap
      for row in range(rows):
        for col in range(cols):
          d = (cx-col)*(cx-col)+(cy-row)*(cy-row)
          if d < radius*radius and d>0.5*radius*radius:
            grid[row][col] = 0
    saved_input = grid.copy()
    saved_input[saved_input!=99]=255
    saved_input[saved_input==99]=0
    ########################################################################################
    N = 512
    rows,cols = N,N
    variable_number = -1*np.ones((rows,cols),dtype=int)
    freq_in_THz = 1.+random.random()*4. # [1,5]
    J,variable_number = run_code(freq_in_THz,rows,cols,grid,variable_number)
    plt.imshow(saved_input,cmap='jet',interpolation='nearest')
    plt.colorbar()
    plt.show()
    plt.imshow(np.real(J),cmap='jet',interpolation='nearest')
    plt.colorbar()
    plt.show()
    plt.imshow(np.imag(J),cmap='jet',interpolation='nearest')
    plt.colorbar()
    plt.show()
    np.save('/content/drive/MyDrive/CNT/'+str(loop)+'_input',np.float32(saved_input))
    np.save('/content/drive/MyDrive/CNT/'+str(loop)+'_real_output',np.real(J))
    np.save('/content/drive/MyDrive/CNT/'+str(loop)+'_imag_output',np.imag(J))
    freq_list.append(freq_in_THz)
    # if loop = 0
    # you save: 0_input, 0_real_output, 0_imag_output, freq_list[0]
  except:
    print(str(loop)+" error")

# at the end of the 100 loops, remember to save freq_list!!!!
from numpy import asarray
np.save('/content/drive/MyDrive/CNT/freq_list',np.asarray(np.float32(freq_list)))

plt.imshow(abs(J),cmap='jet',interpolation='nearest')
plt.colorbar()
plt.show()

"""CNT Polygon"""

import random
import math
from matplotlib import pyplot as plt
import numpy as np

def create_obstruction():
  angle = 0
  min_r,max_r = 150,180
  radius = random.randint(min_r,max_r) # your first point
  center_col,top_row = 256,180   # shape is confined to row = [100,280] and col = [332,692]
  r = []
  points = []
  number_of_points = 6
  for count in range(0,number_of_points): # will make 5 points ending at 180 degrees
    angle = 0.5*math.pi*(count/(number_of_points-1))
    radius = random.randint(min_r,max_r)
    r.append(radius)
    points.append([top_row+radius*math.sin(angle),center_col+radius*math.cos(angle)])

  obstructions_half = np.zeros((512,512-256),dtype=int)
  for count in range(0,len(points)):
    if count == 0:
      my_point = points[count]
      row_1,col_1 = top_row,256-256
      row_2,col_2 = my_point[0],my_point[1]-256
      total_dots = 500
      for dots in range(0,total_dots):
        row = row_1+(row_2-row_1)*(dots/(total_dots-1))
        col = col_1+(col_2-col_1)*(dots/(total_dots-1))
        obstructions_half[round(row)][round(col)] = 99
    else:
      my_point1 = points[count]
      my_point2 = points[count-1]
      row_1,col_1 = my_point1[0],my_point1[1]-256
      row_2,col_2 = my_point2[0],my_point2[1]-256
      total_dots = 500
      for dots in range(0,total_dots):
        row = row_1+(row_2-row_1)*(dots/(total_dots-1))
        col = col_1+(col_2-col_1)*(dots/(total_dots-1))
        obstructions_half[round(row)][round(col)] = 99

  obstructions = np.zeros((512,512),dtype=int)
  obstructions[:,256:512] = obstructions_half[:,:]
  for row in range(0,512):
    for col in range(0,256):
      if obstructions_half[row][255-col] == 99:
        obstructions[row][col] = 99

  new_active = []
  my_list = []
  starting_point = []
  start_row = top_row+25 # should be below the top edge of the obstruction
  start_col = 256
  N = 512
  starting_point.append([start_row, start_col])
  for pts in range(0,len(starting_point)):
    current_starting_point = starting_point[pts]
    start_row = current_starting_point[0]
    start_col = current_starting_point[1]
    my_list.append([start_row,start_col])
    old_active = []
    old_active.append([start_row, start_col])
    points_added = 99
    while points_added > 0:
      points_added = 0
      for doofy in range(0,len(old_active)):
        current_pt = old_active[doofy]
        row = current_pt[0]
        col = current_pt[1]

        # look up
        if row-1 >= 0:
          if obstructions[row - 1][col] != 99:
            my_list.append([row - 1, col])
            points_added = points_added + 1
            obstructions[row - 1][col] = 99
            new_active.append([row-1,col])

        # look down
        if row+1 <= N-1:
          if obstructions[row + 1][col] != 99:
            my_list.append([row + 1, col])
            points_added = points_added + 1
            obstructions[row + 1][col] = 99
            new_active.append([row+1,col])

        # look left
        if col-1 >= 0:
          if obstructions[row][col - 1] != 99:
            my_list.append([row, col - 1])
            points_added = points_added + 1
            obstructions[row][col - 1] = 99
            new_active.append([row,col-1])

        # look right
        if col+1 <= N-1:
          if obstructions[row][col + 1] != 99:
            my_list.append([row, col + 1])
            points_added = points_added + 1
            obstructions[row][col + 1] = 99
            new_active.append([row,col+1])

      old_active = new_active.copy()
      new_active = []
  return obstructions

obstructions = create_obstruction()
plt.imshow(obstructions)
plt.colorbar()
plt.show()
my_row,my_col = 0,0
radius = random.randint(22,27)
points = []
while my_row < 512 and my_col < 512:
  if obstructions[my_row,my_col] == 99:
    points.append([my_row,my_col])
    my_col = my_col + 2*radius - 1
    if my_col >= 511:
      my_row = my_row + 2*radius - 1
      my_col = 0
      print(str(my_row)+","+str(my_col))
  else:
    my_col = my_col + 1
    if my_col > 511:
      my_col = 0
      my_row = my_row + 2*radius - 1

grid = 99*np.ones((512,512),dtype=int)
for pt in range(len(points)):
  my_pt = points[pt]
  cy,cx = my_pt[0],my_pt[1]
  radius2 = radius+2 # add 2 or 3 to promote overlap
  for row in range(cy-radius2-5,cy+radius2+5):
    for col in range(cx-radius2-5,cx+radius2+5):
      d = (cx-col)*(cx-col)+(cy-row)*(cy-row)
      if d < radius2*radius2 and d>0.5*radius2*radius2:
        grid[row][col] = 0

plt.imshow(grid)
plt.colorbar()
plt.show()

"""CNT Bezier"""

import numpy as np
import matplotlib.pyplot as plt
import random
import math
def get_bezier_coef(points):
    n = len(points) - 1

    C = 4 * np.identity(n)
    np.fill_diagonal(C[1:], 1)
    np.fill_diagonal(C[:, 1:], 1)
    C[0, 0] = 2
    C[n - 1, n - 1] = 7
    C[n - 1, n - 2] = 2

    P = [2 * (2 * points[i] + points[i + 1]) for i in range(n)]
    P[0] = points[0] + 2 * points[1]
    P[n - 1] = 8 * points[n - 1] + points[n]

    A = np.linalg.solve(C, P)
    B = [0] * n
    for i in range(n - 1):
        B[i] = 2 * points[i + 1] - A[i + 1]
    B[n - 1] = (A[n - 1] + points[n]) / 2

    return A, B

def get_cubic(a, b, c, d):
    return lambda t: np.power(1 - t, 3) * a + 3 * np.power(1 - t, 2) * t * b + 3 * (1 - t) * np.power(t, 2) * c + np.power(t, 3) * d

def get_bezier_cubic(points):
    A, B = get_bezier_coef(points)
    return [
        get_cubic(points[i], A[i], B[i], points[i + 1])
        for i in range(len(points) - 1)
    ]

def evaluate_bezier(points, n):
    curves = get_bezier_cubic(points)
    return np.array([fun(t) for fun in curves for t in np.linspace(0, 1, n)])

number_of_points = 10
center_col,center_row = 256,256
angle = 0
min_r,max_r = 100,180
radius = random.randint(min_r,max_r)
r = []
r.append(radius)
first_x,first_y = center_col+radius*math.cos(angle),center_row+radius*math.sin(angle)
points = [[first_x,first_y]]
for count in range(1,number_of_points+1):
  angle = 2*math.pi*(count/(number_of_points+1))
  radius = random.randint(min_r,max_r)
  r.append(radius)
  points.append([center_col+radius*math.cos(angle),center_row+radius*math.sin(angle)])
points.append([first_x,first_y])
points=np.vstack(points)
path = evaluate_bezier(points, 300)
x, y = points[:,0], points[:,1]
px, py = path[:,0], path[:,1]
obstructions = np.zeros((512,512))
for count in range(0,len(px)):
  obstructions[511-round(py[count])][round(px[count])] = 1
for count in range(0,len(x)):
  obstructions[511-round(y[count])][round(x[count])] = 1
for row in range(0,512):
  col = 0
  while col <= 511 and obstructions[row][col] == 0:
    obstructions[row][col] = 0.5
    col = col + 1
for row in range(0,512):
  col = 511
  while col >= 0 and obstructions[row][col] == 0:
    obstructions[row][col] = 0.5
    col = col - 1
for col in range(0,512):
  for row in range(1,256):
    if obstructions[row][col] == 1 and obstructions[row-1][col] == 0 and obstructions[row+1][col] == 0:
      for row2 in range(0,row):
        obstructions[row2][col] = 0.5
    if obstructions[row][col] == 1 and obstructions[row-1][col] == 0 and obstructions[row+1][col] == 1 and obstructions[row+2][col] == 0:
      for row2 in range(0,row):
        obstructions[row2][col] = 0.5
for col in range(0,512):
  for row in range(1,256):
    row = 511-row
    if obstructions[row][col] == 1 and obstructions[row-1][col] == 0 and obstructions[row+1][col] == 0:
      for row2 in range(row,512):
        obstructions[row2][col] = 0.5
    if obstructions[row][col] == 1 and obstructions[row+1][col] == 0 and obstructions[row-1][col] == 1 and obstructions[row-2][col] == 0:
      for row2 in range(row,512):
        obstructions[row2][col] = 0.5
obstructions[obstructions ==1] = 0
obstructions[obstructions ==0.5] = 99
grid = np.zeros((512,512),dtype=int)
for row in range(512):
  for col in range(512):
    if obstructions[row,col] < 0.1:
      grid[row,col] = 99
obstructions = grid.copy()
plt.imshow(obstructions)
plt.colorbar()
plt.title("Bezier")
plt.show()
my_row,my_col = 0,0
radius = random.randint(22,27)
points = []
while my_row < 512 and my_col < 512:
  if obstructions[my_row,my_col] == 99:
    points.append([my_row,my_col])
    my_col = my_col + 2*radius - 1
    if my_col >= 511:
      my_row = my_row + 2*radius - 1
      my_col = 0
  else:
    my_col = my_col + 1
    if my_col > 511:
      my_col = 0
      my_row = my_row + 2*radius - 1
grid = 99*np.ones((512,512),dtype=int)
for pt in range(len(points)):
  my_pt = points[pt]
  cy,cx = my_pt[0],my_pt[1]
  radius2 = radius+2 # add 2 or 3 to promote overlap
  for row in range(cy-radius2-5,cy+radius2+5):
    for col in range(cx-radius2-5,cx+radius2+5):
      d = (cx-col)*(cx-col)+(cy-row)*(cy-row)
      if d < radius2*radius2 and d>0.5*radius2*radius2:
        grid[row][col] = 0
plt.imshow(grid)
plt.colorbar()
plt.show()

"""MAKE INPUT SHRINK"""

import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
import tensorflow as tf
from keras import backend as K
import time
import keras
import random
import pandas as pd
import math
from matplotlib.pyplot import figure
from scipy import interpolate
from numba import jit
from keras.initializers import RandomNormal
import matplotlib.colors as colors
from numba import int64, int32, float32, float64, prange, types   # import the types
from numba.experimental import jitclass
from keras.layers import BatchNormalization
from numba.typed import List
from numba import njit
from numba import prange
from keras.layers import Conv1D, Conv2D, MaxPooling2D, AveragePooling1D, AveragePooling2D, Flatten
from keras.layers import LeakyReLU
from keras.layers import Activation
from keras.layers import GaussianNoise

keras.utils.set_random_seed(0)
for loop in range(0,3):
  try:
    img = np.float32(np.load('/content/drive/MyDrive/CNT/'+str(loop)+'_input.npy'))
    shape = img.shape
    img = img.reshape(1, *shape, 1)
    d = Conv2D(64, (4,4), strides=(2,2), padding='same', kernel_initializer=RandomNormal(stddev=0.02))(img)
    d = LeakyReLU(alpha=0.2)(d)
    d = Conv2D(128, (4,4), strides=(2,2), padding='same', kernel_initializer=RandomNormal(stddev=0.02))(d)
    d = MaxPooling2D(pool_size=(2, 2))(d)
    d = BatchNormalization()(d)
    d = LeakyReLU(alpha=0.2)(d)
    d = Conv2D(256, (4,4), strides=(2,2), padding='same', kernel_initializer=RandomNormal(stddev=0.02))(d)
    d = BatchNormalization()(d)
    d = LeakyReLU(alpha=0.2)(d)
    d = Conv2D(512, (4,4), strides=(2,2), padding='same', kernel_initializer=RandomNormal(stddev=0.02))(d)
    d = MaxPooling2D(pool_size=(2, 2))(d)
    d = BatchNormalization()(d)
    d = LeakyReLU(alpha=0.2)(d)
    d = Conv2D(512, (4,4), padding='same', kernel_initializer=RandomNormal(stddev=0.02))(d)
    d = BatchNormalization()(d)
    d = LeakyReLU(alpha=0.2)(d)
    d = Conv2D(1, (4,4), padding='same', kernel_initializer=RandomNormal(stddev=0.02))(d)
    d = Activation('sigmoid')(d)
    d = Flatten()(d)
    d = tf.reshape(d,(round(N/64),round(N/64)))
    d = d.numpy()
    plt.imshow(d)
    plt.title(str(loop))
    plt.colorbar()
    plt.show()
    np.save('/content/drive/MyDrive/CNT/'+str(loop)+'_input_shrunk',d)
  except:
    pass

for loop in range(0,3):
  try:
    input = np.float32(np.load('/content/drive/MyDrive/CNT/'+str(loop)+'_input.npy'))
    input_shrunk = np.float32(np.load('/content/drive/MyDrive/CNT/'+str(loop)+'_input_shrunk.npy'))
    alpha = np.float32(np.load('/content/drive/MyDrive/CNT/'+str(loop)+'_real_output.npy'))
    beta = np.float32(np.load('/content/drive/MyDrive/CNT/'+str(loop)+'_imag_output.npy'))
    plt.imshow(input)
    plt.title("input")
    plt.colorbar()
    plt.show()
    plt.imshow(input_shrunk)
    plt.title("input shrunk")
    plt.colorbar()
    plt.show()
    plt.imshow(alpha)
    plt.title("real part")
    plt.colorbar()
    plt.show()
    plt.imshow(beta)
    plt.title("imag part")
    plt.colorbar()
    plt.show()
  except:
    pass

# You can do this later

# my_Neuman_left = []
# my_Neuman_right = []
# my_Neuman_above = []
# my_Neuman_below = []

# # save them as arrays using asarray

# boundary = np.zeros((rows,cols)) # should be an array of boundary values of float
# for row in range(1,rows-1):
#   for col in range(1,cols-1):
#     if obstruction[row][col] == 99:
#             if obstruction[row-1][col] == 2:
#                 # Top edge (Dirichlet)
#                 boundary[row-1][col] = 1 # 1 means J = 1 Ampere
#             elif obstruction[row-1][col] == 0:
#                 # Top edge (Neumann)
#                 boundary[row-1][col] = obstruction[row+1][col]   # you are setting interior boundaries to J = 99 Ampere
#                 my_Neuman_above.append([row,col])

#             if obstruction[row+1][col] == 2:
#                 # Bottom edge (Dirichlet)
#                 boundary[row+1][col] = 1
#             elif obstruction[row+1][col] == 0:
#                 # Bottom edge (Neumann)
#                 boundary[row+1][col] = obstruction[row-1][col]
#                 my_Neuman_below.append([row+1,col])

#             if obstruction[row][col-1] == 2:
#                 # Left edge (Dirichlet)
#                 boundary[row][col-1] = 1
#             elif obstruction[row][col-1] == 0:
#                 # Left edge (Neumann)
#                 boundary[row][col-1] = obstruction[row][col+1]
#                 my_Neuman_left.append([row,col])

#             if obstruction[row][col+1] == 2:
#                 # Right edge (Dirichlet)
#                 boundary[row][col+1] = 1
#             elif obstruction[row][col+1] == 0:
#                 # Right edge (Neumann)
#                 boundary[row][col+1] = obstruction[row][col-1]
#                 my_Neuman_right.append([row,col+1])

# plt.imshow(boundary)
# plt.colorbar()
# plt.show()

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
import tensorflow as tf
from keras import backend as K
import time
import keras
import random
import pandas as pd
import math
from matplotlib.pyplot import figure
from scipy import interpolate
from numba import jit
import matplotlib.colors as colors
from numba import int64, int32, float32, float64, prange, types   # import the types
from numba.experimental import jitclass
from numba.typed import List
from numba import njit
from numba import prange

# small training dataset (1M points) is needed to prevent moving the goalpost. Also sets your training time.
# input is 1M x 66
# output is 1M x 2

input = np.load('/content/drive/MyDrive/CNT/input_dataset.npy')
output = np.load('/content/drive/MyDrive/CNT/output_dataset.npy')

input_list = np.float32(np.load('/content/drive/MyDrive/CNT/input_list.npy'))
input_shrunk_list = np.float32(np.load('/content/drive/MyDrive/CNT/input_shrunk_list.npy')) # scaled
real_list = np.float32(np.load('/content/drive/MyDrive/CNT/real_list.npy'))                 # scaled
imag_list = np.float32(np.load('/content/drive/MyDrive/CNT/imag_list.npy'))                 # scaled
print(input_list.shape)
print(input_shrunk_list.shape)
print(real_list.shape)
print(imag_list.shape)

# this is for sampling inside the custom loss

# Step 1: randomly pick a data point. Like, pick data point 300
# Step 2: take index 300 of input_shrunk_list, real_list, and imag_list
# Step 3: pick a random row and col.
# Step 4: use the original 512x512 input to verify that your chosen row,col doesn't fall outside the CNT.
# Step 5: create a data point. Input is 64+row+col. Output is real[row,col] + imag[row,col]

random_point = random.randint(0,1108) # from 0 to 1108 inclusive

doof = input_list[:,:,[random_point]].reshape(512,512)
plt.imshow(doof)
plt.title("input")
plt.colorbar()
plt.show()

doof = input_shrunk_list[:,:,[random_point]].reshape(8,8)
plt.imshow(doof)
plt.title("input shrunk (scaled -1 to 1)")
plt.colorbar()
plt.show()

doof = real_list[:,:,[random_point]].reshape(512,512)
plt.imshow(doof)
plt.title("real (scaled -1 to 1)")
plt.colorbar()
plt.show()

doof = imag_list[:,:,[random_point]].reshape(512,512)
plt.imshow(doof)
plt.title("imag (scaled -1 to 1)")
plt.colorbar()
plt.show()

def custom_loss_wrapper(freq_list,input_list,input_shrunk_list,real_list,imag_list):
  def create_obstruction():
    angle = 0
    min_r,max_r = 150,180
    radius = random.randint(min_r,max_r) # your first point
    center_col,top_row = 256,180   # shape is confined to row = [100,280] and col = [332,692]
    r = []
    points = []
    number_of_points = 6
    for count in range(0,number_of_points): # will make 5 points ending at 180 degrees
      angle = 0.5*math.pi*(count/(number_of_points-1))
      radius = random.randint(min_r,max_r)
      r.append(radius)
      points.append([top_row+radius*math.sin(angle),center_col+radius*math.cos(angle)])

    obstructions_half = np.zeros((512,512-256),dtype=int)
    for count in range(0,len(points)):
      if count == 0:
        my_point = points[count]
        row_1,col_1 = top_row,256-256
        row_2,col_2 = my_point[0],my_point[1]-256
        total_dots = 500
        for dots in range(0,total_dots):
          row = row_1+(row_2-row_1)*(dots/(total_dots-1))
          col = col_1+(col_2-col_1)*(dots/(total_dots-1))
          obstructions_half[round(row)][round(col)] = 99
      else:
        my_point1 = points[count]
        my_point2 = points[count-1]
        row_1,col_1 = my_point1[0],my_point1[1]-256
        row_2,col_2 = my_point2[0],my_point2[1]-256
        total_dots = 500
        for dots in range(0,total_dots):
          row = row_1+(row_2-row_1)*(dots/(total_dots-1))
          col = col_1+(col_2-col_1)*(dots/(total_dots-1))
          obstructions_half[round(row)][round(col)] = 99

    obstructions = np.zeros((512,512),dtype=int)
    obstructions[:,256:512] = obstructions_half[:,:]
    for row in range(0,512):
      for col in range(0,256):
        if obstructions_half[row][255-col] == 99:
          obstructions[row][col] = 99

    new_active = []
    my_list = []
    starting_point = []
    start_row = top_row+25 # should be below the top edge of the obstruction
    start_col = 256
    N = 512
    starting_point.append([start_row, start_col])
    for pts in range(0,len(starting_point)):
      current_starting_point = starting_point[pts]
      start_row = current_starting_point[0]
      start_col = current_starting_point[1]
      my_list.append([start_row,start_col])
      old_active = []
      old_active.append([start_row, start_col])
      points_added = 99
      while points_added > 0:
        points_added = 0
        for doofy in range(0,len(old_active)):
          current_pt = old_active[doofy]
          row = current_pt[0]
          col = current_pt[1]

          # look up
          if row-1 >= 0:
            if obstructions[row - 1][col] != 99:
              my_list.append([row - 1, col])
              points_added = points_added + 1
              obstructions[row - 1][col] = 99
              new_active.append([row-1,col])

          # look down
          if row+1 <= N-1:
            if obstructions[row + 1][col] != 99:
              my_list.append([row + 1, col])
              points_added = points_added + 1
              obstructions[row + 1][col] = 99
              new_active.append([row+1,col])

          # look left
          if col-1 >= 0:
            if obstructions[row][col - 1] != 99:
              my_list.append([row, col - 1])
              points_added = points_added + 1
              obstructions[row][col - 1] = 99
              new_active.append([row,col-1])

          # look right
          if col+1 <= N-1:
            if obstructions[row][col + 1] != 99:
              my_list.append([row, col + 1])
              points_added = points_added + 1
              obstructions[row][col + 1] = 99
              new_active.append([row,col+1])

        old_active = new_active.copy()
        new_active = []
    return obstructions

  def input_shrinker(img):
    shape = img.shape
    img = img.reshape(1, *shape, 1)
    d = Conv2D(64, (4,4), strides=(2,2), padding='same', kernel_initializer=RandomNormal(stddev=0.02))(img)
    d = LeakyReLU(alpha=0.2)(d)
    d = Conv2D(128, (4,4), strides=(2,2), padding='same', kernel_initializer=RandomNormal(stddev=0.02))(d)
    d = MaxPooling2D(pool_size=(2, 2))(d)
    d = BatchNormalization()(d)
    d = LeakyReLU(alpha=0.2)(d)
    d = Conv2D(256, (4,4), strides=(2,2), padding='same', kernel_initializer=RandomNormal(stddev=0.02))(d)
    d = BatchNormalization()(d)
    d = LeakyReLU(alpha=0.2)(d)
    d = Conv2D(512, (4,4), strides=(2,2), padding='same', kernel_initializer=RandomNormal(stddev=0.02))(d)
    d = MaxPooling2D(pool_size=(2, 2))(d)
    d = BatchNormalization()(d)
    d = LeakyReLU(alpha=0.2)(d)
    d = Conv2D(512, (4,4), padding='same', kernel_initializer=RandomNormal(stddev=0.02))(d)
    d = BatchNormalization()(d)
    d = LeakyReLU(alpha=0.2)(d)
    d = Conv2D(1, (4,4), padding='same', kernel_initializer=RandomNormal(stddev=0.02))(d)
    d = Activation('sigmoid')(d)
    d = Flatten()(d)
    d = tf.reshape(d,(round(N/64),round(N/64)))
    d = d.numpy()
    return d

  def custom_loss(y_true,y_pred):

    batch=512

    # Step 1: choose a random wrapper training point
    random_point = random.randint(0,1108)
    obstruction = input_list[:,:,[random_point]].reshape(512,512)
    input_shrunk = input_shrunk_list[:,:,[random_point]].reshape(1,64) # make into 64 inputs
    alpha = real_list[:,:,[random_point]].reshape(512,512)
    beta = imag_list[:,:,[random_point]].reshape(512,512)
    freq_in_THz = freq_list[random_point]
    f_max,f_middle = 5.,0.5*(1.+5.)
    freq_in_THz = (freq_in_THz-f_middle)/(f_max-f_middle)

    # Step 2: find viable x and y values

    y = []
    x = []

    test_input = []
    test_alpha = []
    test_beta = []
    while len(y)<batch:
      # choose row and unscale
      choose_y = random.uniform(-1,1)
      max, middle = 511., 0.5*(511.+0.)
      row = int(choose_y*(max-middle)+middle)
      # choose col and unscale
      choose_x = random.uniform(-1,1)
      max, middle = 511., 0.5*(511.+0.)
      col = int(choose_x*(max-middle)+middle)
      if obstruction[row][col] > 250:    # inside the CNT is "255" and outside is "0"
        # you are inside the CNT
        y.append(choose_y)
        x.append(choose_x)
        my_tuple = tuple(input_shrunk)                              # input_shrunk already scaled
        my_tuple = list(my_tuple)
        max,middle = 511.,0.5*(511.+0.)                             # max,middle for row and col
        my_tuple = np.append(my_tuple, choose_y)                    # you can append whatever you like to your tuple
        my_tuple = np.append(my_tuple, choose_x)
        my_tuple = np.append(my_tuple, freq_in_THz)
        my_tuple = tuple(my_tuple)
        test_input.append(my_tuple)
        test_alpha.append(alpha[row,col])
        test_beta.append(beta[row,col])

    y = np.float32(np.vstack(y))
    x = np.float32(np.vstack(x))
    test_input = np.vstack(test_input)   # 512 x 66
    test_alpha = np.vstack(test_alpha)   # 512 x 1
    test_beta = np.vstack(test_beta)     # 512 x 1

    alpha,beta = tf.split(model(test_input),2,axis=1)
    mse = tf.keras.losses.MeanSquaredError()
    total_supervised_losses = mse(y_true,y_pred)+mse(alpha,test_alpha)+mse(beta,test_beta)

    ##########################################################################################################

    # NOTE: when you are minimizing residuals, you CAN choose to recycle one of the input shapes from "input_list".
    # But, you are free to create a new shape and a new frequency if you wish :)

    obstruction = create_obstruction()
    input_shrunk = input_shrinker(obstruction)
    freq_in_THz = 1.0+random.random()*4.0

    # Step 3: minimize residuals
    dx,dy = 1E-09,1E-09
    omega =2*math.pi*freq_in_THz*10**12
    mu = 4*math.pi*10**-7
    sigma = 59*10**6
    f_max,f_middle = 5.,0.5*(1.+5.)
    freq_in_THz = (freq_in_THz-f_middle)/(f_max-f_middle)

    freq_array = freq_in_THz*np.ones((batch,1),dtype=np.float32)

    input_shrunk_batch = np.tile(input_shrunk, (batch, 1))  # duplicate input_shrunk to match batch
    alpha,beta = tf.split(model(np.hstack((input_shrunk_batch,y,x,freq_array))),2,axis=1)
    alpha_r,beta_r = tf.split(model(np.hstack((input_shrunk_batch,y,x+dx,freq_array))),2,axis=1)
    alpha_l,beta_l = tf.split(model(np.hstack((input_shrunk_batch,y,x-dx,freq_array))),2,axis=1)
    alpha_a,beta_a = tf.split(model(np.hstack((input_shrunk_batch,y-dy,x,freq_array))),2,axis=1)
    alpha_b,beta_b = tf.split(model(np.hstack((input_shrunk_batch,y+dy,x,freq_array))),2,axis=1)
    # unscale alpha
    alpha_max,alpha_middle = 0.6171588,0.5*(0.6171588-0.048985485)
    alpha = alpha*(alpha_max-alpha_middle)+alpha_middle
    alpha_r = alpha_r*(alpha_max-alpha_middle)+alpha_middle
    alpha_l = alpha_l*(alpha_max-alpha_middle)+alpha_middle
    alpha_a = alpha_a*(alpha_max-alpha_middle)+alpha_middle
    alpha_b = alpha_b*(alpha_max-alpha_middle)+alpha_middle
    # unscale beta
    beta_max,beta_middle = 1.000,0.5*(1.000-0.17173274)
    beta = beta*(beta_max-beta_middle)+beta_middle
    beta_r = beta_r*(beta_max-beta_middle)+beta_middle
    beta_l = beta_l*(beta_max-beta_middle)+beta_middle
    beta_a = beta_a*(beta_max-beta_middle)+beta_middle
    beta_b = beta_b*(beta_max-beta_middle)+beta_middle

    Loss_eq1 = mse((alpha_l-2*alpha+alpha_r)+(alpha_a-2*alpha+alpha_b) + dx**2*beta*sigma*omega*mu,0)
    Loss_eq2 = mse((beta_l-2*beta+beta_r) + (beta_a-2*beta+beta_b) - dx**2*alpha*sigma*omega*mu,0)

    return total_supervised_losses+2*10**4*(Loss_eq1+Loss_eq2)
  return custom_loss

X = pd.DataFrame(data=input[0:,0:],index=[i for i in range(input.shape[0])],columns=['f'+str(i) for i in range(input.shape[1])])
Y = pd.DataFrame(data=output[0:,0:],index=[i for i in range(output.shape[0])],columns=['f'+str(i) for i in range(output.shape[1])])
X_train, X_test, Y_train, Y_test = train_test_split(X,Y,test_size = 0.1,random_state=0)

model = keras.models.Sequential()
model.add(keras.layers.Dense(200,activation='tanh',input_shape=(67,)))
model.add(keras.layers.Dense(200,activation='tanh'))
model.add(keras.layers.Dense(200,activation='tanh'))
model.add(keras.layers.Dense(200,activation='tanh'))
model.add(keras.layers.Dense(2,activation='tanh'))
optimizer = tf.keras.optimizers.Adam(learning_rate=0.000625,beta_1=0.9,beta_2=0.99)
model.compile(optimizer=optimizer,loss=custom_loss_wrapper(freq_list,input_list,input_shrunk_list,real_list,imag_list))
model.fit(X_train,Y_train,epochs=40,batch_size=128)
model.save('/content/drive/MyDrive/CNT/PI_CNN_1.h5')
Y_pred = model.predict(X_test)
print(mean_squared_error(Y_pred,Y_test))

from tensorflow.keras.models import load_model
import tensorflow.keras
import tensorflow as tf

# input_list,input_shrunk_list,real_list,imag_list = 1,1,1,1
model = tensorflow.keras.models.load_model('/content/drive/MyDrive/CNT/PI_CNN_1.h5',custom_objects={'custom_loss':custom_loss_wrapper(freq_list,input_list,input_shrunk_list,real_list,imag_list)}, compile=False)

point = random.randint(0,1108)
input = np.float32(np.load('/content/drive/MyDrive/CNT/'+str(point)+'_input.npy'))
input_shrunk = np.float32(np.load('/content/drive/MyDrive/CNT/'+str(point)+'_input_shrunk.npy'))

# scale input_shrunk
max,middle = 1.0,0.5*(1.0+0.0)
input_shrunk = (input_shrunk-middle)/(max-middle)
input_shrunk = input_shrunk.reshape(1,64)

############ CHOOSE YOUR FREQUENCY! ############
freq_in_THZ = 2.5
################################################

f_max,f_middle = 5.,0.5*(1.+5.)
freq_in_THz = (freq_in_THz-f_middle)/(f_max-f_middle)
test_input = []
for row in range(0,512):
  for col in range(0,512):
    my_tuple = tuple(input_shrunk)                              # input_shrunk already scaled
    my_tuple = list(my_tuple)
    max,middle = 511.,0.5*(511.+0.)                             # max,middle for row and col
    my_tuple = np.append(my_tuple, (row-middle)/(max-middle))
    my_tuple = np.append(my_tuple, (col-middle)/(max-middle))
    my_tuple = np.append(my_tuple, freq_in_THz)
    my_tuple = tuple(my_tuple)
    test_input.append(my_tuple)
test_input = np.vstack(test_input)

Y_validation = model.predict(test_input)

# scaling for real output, i.e., alpha
alpha_max,alpha_middle = 0.6171588,0.5*(0.6171588-0.048985485)

# scaling for imag output, i.e., beta
beta_max,beta_middle = 1.000,0.5*(1.000-0.17173274)

alpha = tf.gather(Y_validation,[0], axis=1)
alpha = np.array(alpha)
alpha = alpha.reshape(512,512)
alpha = alpha*(alpha_max-alpha_middle)+alpha_middle

beta = tf.gather(Y_validation,[1], axis=1)
beta = np.array(beta)
beta = beta.reshape(512,512)
beta = beta*(beta_max-beta_middle)+beta_middle

J = np.sqrt(np.square(alpha)+np.square(beta))
J[input<250] = 'nan'
plt.imshow(J,cmap='jet',interpolation='nearest')
plt.title("PI CNN "+str(point))
plt.show()

real = np.float32(np.load('/content/drive/MyDrive/CNT/'+str(point)+'_real_output.npy'))
imag = np.float32(np.load('/content/drive/MyDrive/CNT/'+str(point)+'_imag_output.npy'))
J = np.sqrt(np.square(real)+np.square(imag))
J[input<250] = 'nan'
plt.imshow(J,cmap='jet',interpolation='nearest')
plt.title("Ground Truth "+str(point))
plt.show()
